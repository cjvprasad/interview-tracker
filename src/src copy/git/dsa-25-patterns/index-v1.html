<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DSA Mastery | Professional Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />

    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
              mono: ["JetBrains Mono", "monospace"],
            },
            colors: {
              brand: {
                50: "#eff6ff",
                100: "#dbeafe",
                500: "#3b82f6",
                600: "#2563eb",
                900: "#1e3a8a",
              },
              dark: {
                bg: "#0f172a",
                sidebar: "#1e293b",
                card: "#334155",
                border: "#475569",
              },
            },
          },
        },
      };
    </script>
    <style>
      /* Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #475569;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #64748b;
      }

      /* Animations */
      .fade-in {
        animation: fadeIn 0.3s ease-in-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(5px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .active-card {
        border-left: 4px solid #3b82f6;
        background-color: rgba(59, 130, 246, 0.1);
      }
      .nav-btn {
        @apply px-4 py-2 rounded border border-slate-600 text-slate-300 hover:bg-slate-700 hover:text-white transition-colors text-sm flex items-center gap-2;
      }

      /* Badge Colors */
      .badge-Easy {
        @apply bg-green-900/30 text-green-400 border-green-800;
      }
      .badge-Medium {
        @apply bg-yellow-900/30 text-yellow-400 border-yellow-800;
      }
      .badge-Hard {
        @apply bg-red-900/30 text-red-400 border-red-800;
      }

      /* Checkbox Styles */
      .checkbox-wrapper input:checked + div {
        background-color: #10b981; /* Emerald 500 */
        border-color: #10b981;
      }
      .checkbox-wrapper input:checked + div i {
        opacity: 1;
      }

      /* --- EDITOR STYLES --- */
      .editor-container {
        position: relative;
        width: 100%;
        height: 100%;
        font-family: "JetBrains Mono", monospace;
        font-size: 14px;
        line-height: 1.5;
        background-color: #1e1e1e;
      }
      .editor-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 1rem;
        margin: 0;
        border: 0;
        box-sizing: border-box;
        background: transparent;
        white-space: pre;
        overflow: auto;
        word-wrap: normal;
      }
      textarea.editor-layer {
        z-index: 10;
        color: transparent;
        caret-color: white;
        resize: none;
        outline: none;
      }
      pre.editor-layer {
        z-index: 5;
        pointer-events: none;
        color: #ccc;
      }
      /* Prism Overrides */
      code[class*="language-"],
      pre[class*="language-"] {
        text-shadow: none !important;
        font-family: "JetBrains Mono", monospace !important;
        font-size: 14px !important;
        line-height: 1.5 !important;
        padding: 0 !important;
        margin: 0 !important;
        background: transparent !important;
      }
    </style>
  </head>
  <body
    class="h-screen w-screen overflow-hidden bg-[#0f172a] text-slate-200 font-sans flex flex-col md:flex-row"
  >
    <aside
      id="sidebar-panel"
      class="w-full md:w-80 flex-shrink-0 flex flex-col border-r border-slate-700 bg-[#1e293b] h-full absolute md:relative z-20 transform transition-transform duration-300 md:translate-x-0"
    >
      <div
        class="h-16 flex items-center justify-between px-6 border-b border-slate-700 bg-[#1e293b] z-10 shrink-0"
      >
        <div class="flex items-center gap-3">
          <div
            class="w-8 h-8 bg-brand-600 rounded-lg flex items-center justify-center text-white shadow-lg shadow-brand-500/30"
          >
            <i class="fa-solid fa-layer-group"></i>
          </div>
          <span class="font-bold text-lg tracking-tight text-white"
            >DSA Mastery</span
          >
        </div>
        <button
          onclick="toggleAllPhases()"
          class="text-slate-400 hover:text-white transition-colors"
          title="Expand/Collapse All"
        >
          <i id="toggle-all-icon" class="fa-solid fa-expand"></i>
        </button>
      </div>

      <div
        class="flex-1 overflow-y-auto p-3 space-y-6"
        id="sidebar-content"
      ></div>

      <div class="p-4 border-t border-slate-700 bg-[#1e293b] shrink-0">
        <div class="flex justify-between text-xs text-slate-400 mb-2">
          <span>Global Progress</span>
          <span id="global-progress-text">0%</span>
        </div>
        <div class="w-full h-2 bg-slate-700 rounded-full overflow-hidden">
          <div
            id="global-progress-bar"
            class="h-full bg-brand-500 w-0 transition-all duration-500"
          ></div>
        </div>
        <button
          onclick="resetData()"
          class="mt-3 w-full py-2 text-xs text-red-400 hover:bg-slate-700/50 rounded transition-colors"
        >
          Reset All Data
        </button>
      </div>
    </aside>

    <main
      id="main-panel"
      class="flex-1 flex flex-col min-w-0 bg-[#0f172a] relative h-full w-full hidden md:flex"
    ></main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

    <script>
      // --- DATA STRUCTURES ---
      const phases = [
        { title: "Phase 1: The Foundation", id: "p1" },
        { title: "Phase 2: Core Structures", id: "p2" },
        { title: "Phase 3: Advanced Search", id: "p3" },
        { title: "Phase 4: Dynamic Programming", id: "p4" },
        { title: "Phase 5: Expert Graph Theory", id: "p5" },
      ];

      // UPDATED PATTERNS (With formatted Anchor Logic)
      const patterns = [
        {
          id: 1,
          phase: "p1",
          name: "Sliding Window",
          desc: "Used to perform a required operation on a specific window size of a given array or linked list.",
          strategy:
            "Use 'start' and 'end' pointers. Expand 'end' until condition breaks, then shrink 'start'.",
          anchor: {
            logic:
              "let windowSum = 0, start = 0;\nfor (let end = 0; end < arr.length; end++) {\n  windowSum += arr[end];\n  while (windowSum > target) {\n    windowSum -= arr[start];\n    start++;\n  }\n}",
          },
          problems: [
            "Maximum Sum Subarray of Size K",
            "Smallest Subarray with a given sum",
            "Longest Substring with K Distinct Characters",
            "Fruits into Baskets",
          ],
        },
        {
          id: 2,
          phase: "p1",
          name: "Two Pointers",
          desc: "Used in sorted arrays to find a set of elements that fulfill a certain constraint.",
          strategy:
            "Initialize two pointers (Left=0, Right=N-1). Move them based on sum comparison.",
          anchor: {
            logic:
              "let left = 0, right = arr.length - 1;\nwhile (left < right) {\n  const sum = arr[left] + arr[right];\n  if (sum === target) return [left, right];\n  else if (sum < target) left++;\n  else right--;\n}",
          },
          problems: [
            "Pair with Target Sum",
            "Remove Duplicates from Sorted Array",
            "Squaring a Sorted Array",
            "3Sum",
          ],
        },
        {
          id: 3,
          phase: "p1",
          name: "Fast & Slow Pointers",
          desc: "Also known as Hare & Tortoise. Used for cycle detection in linked lists.",
          strategy:
            "Move 'fast' pointer 2 steps and 'slow' pointer 1 step. If they meet, there is a cycle.",
          anchor: {
            logic:
              "let slow = head, fast = head;\nwhile (fast && fast.next) {\n  slow = slow.next;\n  fast = fast.next.next;\n  if (slow === fast) return true;\n}\nreturn false;",
          },
          problems: [
            "Linked List Cycle",
            "Middle of the Linked List",
            "Start of Linked List Cycle",
            "Happy Number",
          ],
        },
        {
          id: 4,
          phase: "p1",
          name: "Merge Intervals",
          desc: "Used to deal with overlapping intervals. Efficient for scheduling.",
          strategy:
            "Sort intervals by start time. Iterate and merge if curr.start <= prev.end.",
          anchor: {
            logic:
              "intervals.sort((a, b) => a[0] - b[0]);\nconst merged = [intervals[0]];\nfor (let i = 1; i < intervals.length; i++) {\n  if (curr.start <= prev.end) {\n    prev.end = Math.max(prev.end, curr.end);\n  } else merged.push(curr);\n}",
          },
          problems: [
            "Merge Intervals",
            "Insert Interval",
            "Intervals Intersection",
            "Conflicting Appointments",
          ],
        },
        {
          id: 5,
          phase: "p1",
          name: "Cyclic Sort",
          desc: "Used when numbers are in a given range (1 to N) to find duplicates/missing.",
          strategy:
            "Iterate array. Swap nums[i] to correct index nums[nums[i]-1].",
          anchor: {
            logic:
              "let i = 0;\nwhile (i < n) {\n  const j = nums[i] - 1;\n  if (nums[i] !== nums[j]) swap(i, j);\n  else i++;\n}",
          },
          problems: [
            "Missing Number",
            "Find All Numbers Disappeared in an Array",
            "Find the Duplicate Number",
            "Find All Duplicates in an Array",
          ],
        },
        {
          id: 6,
          phase: "p2",
          name: "List Reversal",
          desc: "Reverse a Linked List in-place, completely or within a range.",
          strategy:
            "Use 'prev', 'curr', and 'next' pointers. Rotate them as you iterate.",
          anchor: {
            logic:
              "let prev = null, curr = head;\nwhile (curr) {\n  let next = curr.next;\n  curr.next = prev;\n  prev = curr;\n  curr = next;\n}\nreturn prev;",
          },
          problems: [
            "Reverse Linked List",
            "Reverse Linked List II",
            "Reverse Nodes in k-Group",
            "Rotate List",
          ],
        },
        {
          id: 7,
          phase: "p2",
          name: "Tree BFS",
          desc: "Breadth-First Search. Traverse a tree level-by-level.",
          strategy: "Use a Queue. Process 'levelSize' nodes at a time.",
          anchor: {
            logic:
              "const q = [root];\nwhile (q.length) {\n  const len = q.length;\n  for (let i = 0; i < len; i++) {\n    const node = q.shift();\n    if (node.left) q.push(node.left);\n    if (node.right) q.push(node.right);\n  }\n}",
          },
          problems: [
            "Binary Tree Level Order Traversal",
            "Binary Tree Zigzag Level Order Traversal",
            "Average of Levels in Binary Tree",
            "Minimum Depth of Binary Tree",
          ],
        },
        {
          id: 8,
          phase: "p2",
          name: "Tree DFS",
          desc: "Depth-First Search. Go deep before backtracking.",
          strategy:
            "Recursion. Process Node, then recursively call DFS on children.",
          anchor: {
            logic:
              "function dfs(node) {\n  if (!node) return;\n  // Process node\n  dfs(node.left);\n  dfs(node.right);\n}",
          },
          problems: [
            "Path Sum",
            "Path Sum II",
            "Path Sum III",
            "Sum Root to Leaf Numbers",
          ],
        },
        {
          id: 9,
          phase: "p2",
          name: "Two Heaps",
          desc: "Find median of a stream or min/max problems efficiently.",
          strategy: "MinHeap (larger half) and MaxHeap (smaller half).",
          anchor: {
            logic:
              "if (num <= maxH.peek()) maxH.push(num);\nelse minH.push(num);\n// Balance sizes\nif (maxH.size > minH.size + 1) minH.push(maxH.pop());",
          },
          problems: [
            "Find Median from Data Stream",
            "Sliding Window Median",
            "IPO",
            "Find Right Interval",
          ],
        },
        {
          id: 10,
          phase: "p2",
          name: "Subsets",
          desc: "Permutations and combinations using BFS.",
          strategy:
            "Start with empty set. For each number, add it to existing subsets.",
          anchor: {
            logic:
              "const subsets = [[]];\nfor (const n of nums) {\n  const len = subsets.length;\n  for (let i = 0; i < len; i++) {\n    subsets.push([...subsets[i], n]);\n  }\n}",
          },
          problems: [
            "Subsets",
            "Subsets II",
            "Permutations",
            "Letter Combinations of a Phone Number",
          ],
        },
        {
          id: 11,
          phase: "p3",
          name: "Binary Search",
          desc: "Find target in sorted array in O(log N).",
          strategy:
            "Calculate mid. If target < mid, search left. Else search right.",
          anchor: {
            logic:
              "let l = 0, r = arr.length - 1;\nwhile (l <= r) {\n  const mid = l + Math.floor((r - l) / 2);\n  if (arr[mid] === t) return mid;\n  if (arr[mid] < t) l = mid + 1;\n  else r = mid - 1;\n}",
          },
          problems: [
            "Binary Search",
            "Search Insert Position",
            "Search in Rotated Sorted Array",
            "Find Peak Element",
          ],
        },
        {
          id: 12,
          phase: "p3",
          name: "Bitwise XOR",
          desc: "Find unique numbers or missing numbers efficiently.",
          strategy: "XOR of a number with itself is 0. XOR with 0 is number.",
          anchor: {
            logic: "let res = 0;\nfor (const n of nums) res ^= n;\nreturn res;",
          },
          problems: [
            "Single Number",
            "Single Number II",
            "Hamming Distance",
            "Total Hamming Distance",
          ],
        },
        {
          id: 13,
          phase: "p3",
          name: "Top K Elements",
          desc: "Find top/smallest/frequent K elements.",
          strategy: "MinHeap (size K) for K largest. MaxHeap for K smallest.",
          anchor: {
            logic:
              "for (const n of nums) {\n  minHeap.push(n);\n  if (minHeap.size() > k) minHeap.pop();\n}",
          },
          problems: [
            "Kth Largest Element in an Array",
            "Top K Frequent Elements",
            "K Closest Points to Origin",
            "Sort Characters By Frequency",
          ],
        },
        {
          id: 14,
          phase: "p3",
          name: "K-way Merge",
          desc: "Merge K sorted lists.",
          strategy:
            "MinHeap with first element of each list. Pop min, push next.",
          anchor: {
            logic:
              "heap.push({val: list[0], idx: 0});\nwhile(heap) {\n  const {val, idx} = heap.pop();\n  res.push(val);\n  if (next) heap.push(next);\n}",
          },
          problems: [
            "Merge K Sorted Lists",
            "Kth Smallest Element in a Sorted Matrix",
            "Find K Pairs with Smallest Sums",
            "Smallest Range Covering Elements from K Lists",
          ],
        },
        {
          id: 15,
          phase: "p4",
          name: "0/1 Knapsack",
          desc: "Items can be selected (1) or not (0).",
          strategy: "2D DP array. dp[i][c] = max(exclude, include).",
          anchor: {
            logic:
              "for (let i = 1; i < n; i++) {\n  for (let c = 1; c <= cap; c++) {\n    if (w[i] <= c) \n      dp[i][c] = Math.max(dp[i-1][c], p[i] + dp[i-1][c-w[i]]);\n    else dp[i][c] = dp[i-1][c];\n  }\n}",
          },
          problems: [
            "Partition Equal Subset Sum",
            "Target Sum",
            "Last Stone Weight II",
            "Ones and Zeroes",
          ],
        },
        {
          id: 16,
          phase: "p4",
          name: "Unbounded Knapsack",
          desc: "Items can be selected unlimited times.",
          strategy: "1D DP. If include item, stay at same index.",
          anchor: {
            logic:
              "for (let c = 1; c <= cap; c++) {\n  for (let i = 0; i < n; i++) {\n    if (w[i] <= c) \n      dp[c] = Math.max(dp[c], p[i] + dp[c - w[i]]);\n  }\n}",
          },
          problems: [
            "Coin Change",
            "Rod Cutting",
            "Integer Break",
            "Perfect Squares",
          ],
        },
        {
          id: 17,
          phase: "p4",
          name: "Fibonacci Sequence",
          desc: "Current state depends on previous states.",
          strategy: "dp[i] = dp[i-1] + dp[i-2]. Use two variables.",
          anchor: {
            logic:
              "let n1 = 0, n2 = 1;\nfor (let i = 2; i <= n; i++) {\n  let temp = n1 + n2;\n  n1 = n2;\n  n2 = temp;\n}",
          },
          problems: [
            "Fibonacci Number",
            "Climbing Stairs",
            "House Robber",
            "Jump Game",
          ],
        },
        {
          id: 18,
          phase: "p4",
          name: "Palindromic Subseq",
          desc: "Palindromes within strings.",
          strategy:
            "Check ends. If match, 2+inner. Else max of skipping left or right.",
          anchor: {
            logic:
              "if (s[i] === s[j]) dp[i][j] = 2 + dp[i+1][j-1];\nelse dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);",
          },
          problems: [
            "Longest Palindromic Substring",
            "Longest Palindromic Subsequence",
            "Palindromic Substrings",
            "Count Different Palindromic Subsequences",
          ],
        },
        {
          id: 19,
          phase: "p4",
          name: "Longest Common Subsequence",
          desc: "Longest subsequence in two sequences.",
          strategy: "2D DP. Match: diag+1. No match: max(top, left).",
          anchor: {
            logic:
              "if (s1[i] === s2[j]) dp[i][j] = 1 + dp[i-1][j-1];\nelse dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);",
          },
          problems: [
            "Longest Common Subsequence",
            "Edit Distance",
            "Distinct Subsequences",
            "Shortest Common Supersequence",
          ],
        },
        {
          id: 20,
          phase: "p5",
          name: "Topological Sort",
          desc: "Scheduling tasks with dependencies (DAGs).",
          strategy: "Kahn's Algo (BFS with in-degrees).",
          anchor: {
            logic:
              "const q = [];\n// push 0 in-degree nodes\nwhile (q.length) {\n  const u = q.shift();\n  list.push(u);\n  graph[u].forEach(v => {\n    inDegree[v]--;\n    if (inDegree[v] === 0) q.push(v);\n  });\n}",
          },
          problems: [
            "Course Schedule",
            "Alien Dictionary",
            "Sequence Reconstruction",
            "Parallel Courses",
          ],
        },
        {
          id: 21,
          phase: "p5",
          name: "Union Find",
          desc: "Disjoint Set Union (DSU). Connectivity.",
          strategy: "Find with path compression. Union by rank.",
          anchor: {
            logic:
              "find(x) {\n  if (p[x] !== x) p[x] = find(p[x]);\n  return p[x];\n}\nunion(x, y) {\n  p[find(x)] = find(y);\n}",
          },
          problems: [
            "Number of Provinces",
            "Redundant Connection",
            "Accounts Merge",
            "Number of Islands II",
          ],
        },
        {
          id: 22,
          phase: "p5",
          name: "Trie",
          desc: "Prefix Tree. String search/autocomplete.",
          strategy: "Tree where edges are chars.",
          anchor: {
            logic:
              "let node = root;\nfor (const c of word) {\n  if (!node.child[c]) node.child[c] = new Node();\n  node = node.child[c];\n}\nnode.isWord = true;",
          },
          problems: [
            "Implement Trie (Prefix Tree)",
            "Design Add and Search Words Data Structure",
            "Word Search II",
            "Replace Words",
          ],
        },
        {
          id: 23,
          phase: "p5",
          name: "Monotonic Stack",
          desc: "Next Greater/Smaller Element.",
          strategy: "Keep stack sorted. Pop on violation.",
          anchor: {
            logic:
              "for (const n of nums) {\n  while (stack.length && n > stack.peek()) {\n    const popped = stack.pop();\n    // Logic\n  }\n  stack.push(n);\n}",
          },
          problems: [
            "Next Greater Element I",
            "Daily Temperatures",
            "Largest Rectangle in Histogram",
            "Trapping Rain Water",
          ],
        },
        {
          id: 24,
          phase: "p5",
          name: "Matrix Traversal",
          desc: "DFS/BFS on 2D grids.",
          strategy: "Traverse neighbors. Mark visited.",
          anchor: {
            logic:
              "function dfs(r, c) {\n  if (outOfBounds || visited[r][c]) return;\n  visited[r][c] = true;\n  dfs(r+1, c); dfs(r-1, c);\n  dfs(r, c+1); dfs(r, c-1);\n}",
          },
          problems: [
            "Number of Islands",
            "Max Area of Island",
            "Flood Fill",
            "Rotting Oranges",
          ],
        },
        {
          id: 25,
          phase: "p5",
          name: "Backtracking",
          desc: "Brute force. Explore all paths.",
          strategy: "Place, Recurse, Backtrack (Undo).",
          anchor: {
            logic:
              "function backtrack(path) {\n  if (goal) { res.push(path); return; }\n  for (let c of choices) {\n    path.push(c);\n    backtrack(path);\n    path.pop();\n  }\n}",
          },
          problems: [
            "N-Queens",
            "Sudoku Solver",
            "Word Search",
            "Generate Parentheses",
          ],
        },
      ];

      // FULL PROBLEMS DATABASE (One solution per pattern for demo)
      const problemsDB = {
        "Maximum Sum Subarray of Size K": {
          difficulty: "Easy",
          desc: "Find max sum of contiguous subarray of size k.",
          examples: [{ input: "[2,1,5,1,3,2], k=3", output: "9" }],
          constraints: ["k > 0"],
          starterCode: "function solve(k, nums) {\n  return 0;\n}",
          solution:
            "function solve(k, nums) {\n  let maxS=0, wSum=0, start=0;\n  for(let end=0; end<nums.length; end++) {\n    wSum+=nums[end];\n    if(end >= k-1) {\n      maxS = Math.max(maxS, wSum);\n      wSum -= nums[start++];\n    }\n  }\n  return maxS;\n}",
          interviewQs: [{ q: "Negative numbers?", a: "Init max to -Infinity" }],
        },

        "Pair with Target Sum": {
          difficulty: "Easy",
          desc: "Find indices of two numbers that add up to target.",
          examples: [{ input: "[1,2,3,4,6], t=6", output: "[1,3]" }],
          constraints: ["Sorted"],
          starterCode: "function solve(nums, t) {\n  return [-1,-1];\n}",
          solution:
            "function solve(nums, t) {\n  let l=0, r=nums.length-1;\n  while(l<r){\n    let s=nums[l]+nums[r];\n    if(s===t) return [l,r];\n    if(s<t) l++; else r--;\n  }\n  return [-1,-1];\n}",
          interviewQs: [{ q: "Unsorted?", a: "HashMap O(N)" }],
        },

        "Linked List Cycle": {
          difficulty: "Easy",
          desc: "Detect if list has cycle.",
          examples: [{ input: "head=[3,2,0,-4]", output: "true" }],
          constraints: [],
          starterCode: "function hasCycle(head) {\n  return false;\n}",
          solution:
            "function hasCycle(head) {\n  let s=head, f=head;\n  while(f && f.next) {\n    s=s.next; f=f.next.next;\n    if(s===f) return true;\n  }\n  return false;\n}",
          interviewQs: [{ q: "O(1) space?", a: "Yes, Floyd's Algo" }],
        },

        "Merge Intervals": {
          difficulty: "Medium",
          desc: "Merge overlapping intervals.",
          examples: [{ input: "[[1,3],[2,6]]", output: "[[1,6]]" }],
          constraints: [],
          starterCode: "function merge(intervals) {\n  return [];\n}",
          solution:
            "function merge(intervals) {\n  intervals.sort((a,b)=>a[0]-b[0]);\n  const res=[intervals[0]];\n  for(let i=1; i<intervals.length; i++) {\n    let prev=res[res.length-1], curr=intervals[i];\n    if(curr[0]<=prev[1]) prev[1]=Math.max(prev[1], curr[1]);\n    else res.push(curr);\n  }\n  return res;\n}",
          interviewQs: [{ q: "Complexity?", a: "O(N log N)" }],
        },

        "Missing Number": {
          difficulty: "Easy",
          desc: "Find missing number in 0..n",
          examples: [{ input: "[3,0,1]", output: "2" }],
          constraints: [],
          starterCode: "function missing(nums) {\n  return 0;\n}",
          solution:
            "function missing(nums) {\n  let i=0, n=nums.length;\n  while(i<n){\n    let j=nums[i];\n    if(j<n && nums[i]!==nums[j]) [nums[i],nums[j]]=[nums[j],nums[i]];\n    else i++;\n  }\n  for(i=0;i<n;i++) if(nums[i]!==i) return i;\n  return n;\n}",
          interviewQs: [{ q: "XOR approach?", a: "XOR index vs value" }],
        },

        "Reverse Linked List": {
          difficulty: "Easy",
          desc: "Reverse a singly linked list.",
          examples: [{ input: "[1,2,3]", output: "[3,2,1]" }],
          constraints: [],
          starterCode: "function reverse(head) {\n  return null;\n}",
          solution:
            "function reverse(head) {\n  let prev=null, curr=head;\n  while(curr){\n    let next=curr.next;\n    curr.next=prev;\n    prev=curr;\n    curr=next;\n  }\n  return prev;\n}",
          interviewQs: [{ q: "Recursive?", a: "Yes" }],
        },

        "Binary Tree Level Order Traversal": {
          difficulty: "Medium",
          desc: "Level-by-level traversal.",
          examples: [
            { input: "[3,9,20,null,null,15,7]", output: "[[3],[9,20],[15,7]]" },
          ],
          constraints: [],
          starterCode: "function levelOrder(root) {\n  return [];\n}",
          solution:
            "function levelOrder(root) {\n  if(!root) return [];\n  let q=[root], res=[];\n  while(q.length){\n    let len=q.length, row=[];\n    for(let i=0;i<len;i++){\n      let n=q.shift();\n      row.push(n.val);\n      if(n.left) q.push(n.left);\n      if(n.right) q.push(n.right);\n    }\n    res.push(row);\n  }\n  return res;\n}",
          interviewQs: [{ q: "DFS vs BFS?", a: "BFS uses Queue" }],
        },

        "Path Sum": {
          difficulty: "Easy",
          desc: "Has root-to-leaf path summing to target?",
          examples: [{ input: "root, 22", output: "true" }],
          constraints: [],
          starterCode: "function hasPathSum(root, t) {\n  return false;\n}",
          solution:
            "function hasPathSum(root, t) {\n  if(!root) return false;\n  if(!root.left && !root.right && t===root.val) return true;\n  return hasPathSum(root.left, t-root.val) || hasPathSum(root.right, t-root.val);\n}",
          interviewQs: [{ q: "Iterative?", a: "Use Stack" }],
        },

        "Find Median from Data Stream": {
          difficulty: "Hard",
          desc: "Find median of stream.",
          examples: [{ input: "add(1), add(2), med()", output: "1.5" }],
          constraints: [],
          starterCode: "class MedianFinder {}",
          solution:
            "// Requires PriorityQueue implementation in JS\n// 1. MaxHeap (small half)\n// 2. MinHeap (large half)\n// Balance sizes.",
          interviewQs: [{ q: "Why Heaps?", a: "O(1) access" }],
        },

        Subsets: {
          difficulty: "Medium",
          desc: "Find all subsets.",
          examples: [{ input: "[1,2,3]", output: "[[],[1],...]" }],
          constraints: [],
          starterCode: "function subsets(nums) {\n  return [];\n}",
          solution:
            "function subsets(nums) {\n  let res=[[]];\n  for(let n of nums){\n    let len=res.length;\n    for(let i=0;i<len;i++) res.push([...res[i], n]);\n  }\n  return res;\n}",
          interviewQs: [{ q: "Count?", a: "2^N" }],
        },

        "Binary Search": {
          difficulty: "Easy",
          desc: "Find target index.",
          examples: [{ input: "[-1,0,3,5,9], 9", output: "4" }],
          constraints: ["Sorted"],
          starterCode: "function search(nums, t) {\n  return -1;\n}",
          solution:
            "function search(nums, t) {\n  let l=0, r=nums.length-1;\n  while(l<=r){\n    let m=Math.floor((l+r)/2);\n    if(nums[m]===t) return m;\n    if(nums[m]<t) l=m+1; else r=m-1;\n  }\n  return -1;\n}",
          interviewQs: [{ q: "Overflow?", a: "l+(r-l)/2" }],
        },

        "Single Number": {
          difficulty: "Easy",
          desc: "Find unique number.",
          examples: [{ input: "[2,2,1]", output: "1" }],
          constraints: [],
          starterCode: "function singleNumber(nums) {\n  return 0;\n}",
          solution:
            "function singleNumber(nums) {\n  let res=0;\n  for(let n of nums) res^=n;\n  return res;\n}",
          interviewQs: [{ q: "XOR logic?", a: "x^x=0" }],
        },

        "Kth Largest Element in an Array": {
          difficulty: "Medium",
          desc: "Find Kth largest.",
          examples: [{ input: "[3,2,1,5,6,4], k=2", output: "5" }],
          constraints: [],
          starterCode: "function findKth(nums, k) {\n  return 0;\n}",
          solution:
            "function findKth(nums, k) {\n  nums.sort((a,b)=>b-a);\n  return nums[k-1];\n}",
          interviewQs: [{ q: "Faster?", a: "QuickSelect O(N)" }],
        },

        "Merge K Sorted Lists": {
          difficulty: "Hard",
          desc: "Merge K lists.",
          examples: [{ input: "[[1,4,5],[1,3,4]]", output: "[1,1,3,4,4,5]" }],
          constraints: [],
          starterCode: "function mergeK(lists) {\n  return null;\n}",
          solution:
            "// Use MinHeap of size K\n// Push heads, pop min, push next",
          interviewQs: [{ q: "Complexity?", a: "N log K" }],
        },

        "Partition Equal Subset Sum": {
          difficulty: "Medium",
          desc: "Can partition into two equal sums?",
          examples: [{ input: "[1,5,11,5]", output: "true" }],
          constraints: [],
          starterCode: "function canPart(nums) {\n  return false;\n}",
          solution:
            "function canPart(nums) {\n  let sum=nums.reduce((a,b)=>a+b,0);\n  if(sum%2!==0) return false;\n  let t=sum/2, dp=new Array(t+1).fill(false);\n  dp[0]=true;\n  for(let n of nums){\n    for(let i=t; i>=n; i--) dp[i]=dp[i]||dp[i-n];\n  }\n  return dp[t];\n}",
          interviewQs: [{ q: "Why backwards?", a: "Reuse array" }],
        },

        "Coin Change": {
          difficulty: "Medium",
          desc: "Fewest coins to make amount.",
          examples: [{ input: "[1,2,5], 11", output: "3" }],
          constraints: [],
          starterCode: "function coinChange(coins, amt) {\n  return -1;\n}",
          solution:
            "function coinChange(coins, amt) {\n  let dp=new Array(amt+1).fill(Infinity);\n  dp[0]=0;\n  for(let c of coins){\n    for(let i=c; i<=amt; i++) dp[i]=Math.min(dp[i], dp[i-c]+1);\n  }\n  return dp[amt]===Infinity?-1:dp[amt];\n}",
          interviewQs: [{ q: "Greedy?", a: "Fails for some cases" }],
        },

        "Fibonacci Number": {
          difficulty: "Easy",
          desc: "F(n).",
          examples: [{ input: "4", output: "3" }],
          constraints: [],
          starterCode: "function fib(n) {\n  return 0;\n}",
          solution:
            "function fib(n) {\n  if(n<2) return n;\n  let a=0, b=1;\n  for(let i=2; i<=n; i++) { let t=a+b; a=b; b=t; }\n  return b;\n}",
          interviewQs: [{ q: "Space?", a: "O(1)" }],
        },

        "Longest Palindromic Substring": {
          difficulty: "Medium",
          desc: "Longest palindrome in s.",
          examples: [{ input: "babad", output: "bab" }],
          constraints: [],
          starterCode: "function longestPal(s) {\n  return '';\n}",
          solution:
            "function longestPal(s) {\n  let max='';\n  const expand=(l,r)=>{\n    while(l>=0 && r<s.length && s[l]===s[r]) {l--;r++;}\n    if(r-l-1>max.length) max=s.substring(l+1,r);\n  };\n  for(let i=0; i<s.length; i++) { expand(i,i); expand(i,i+1); }\n  return max;\n}",
          interviewQs: [{ q: "Manacher?", a: "O(N)" }],
        },

        "Longest Common Subsequence": {
          difficulty: "Medium",
          desc: "LCS of two strings.",
          examples: [{ input: "abcde, ace", output: "3" }],
          constraints: [],
          starterCode: "function lcs(t1, t2) {\n  return 0;\n}",
          solution:
            "function lcs(t1, t2) {\n  let dp=Array(t1.length+1).fill(0).map(()=>Array(t2.length+1).fill(0));\n  for(let i=1; i<=t1.length; i++){\n    for(let j=1; j<=t2.length; j++){\n      if(t1[i-1]===t2[j-1]) dp[i][j]=1+dp[i-1][j-1];\n      else dp[i][j]=Math.max(dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[t1.length][t2.length];\n}",
          interviewQs: [{ q: "Space opt?", a: "2 rows" }],
        },

        "Course Schedule": {
          difficulty: "Medium",
          desc: "Can finish courses?",
          examples: [{ input: "2, [[1,0]]", output: "true" }],
          constraints: [],
          starterCode: "function canFinish(n, p) {\n  return true;\n}",
          solution:
            "function canFinish(n, p) {\n  let g=Array.from({length:n},()=>[]), inD=Array(n).fill(0);\n  for(let [c, pre] of p) { g[pre].push(c); inD[c]++; }\n  let q=[], count=0;\n  for(let i=0;i<n;i++) if(inD[i]===0) q.push(i);\n  while(q.length){\n    let u=q.shift(); count++;\n    for(let v of g[u]) { inD[v]--; if(inD[v]===0) q.push(v); }\n  }\n  return count===n;\n}",
          interviewQs: [{ q: "Algorithm?", a: "Kahn's / Topo Sort" }],
        },

        "Number of Provinces": {
          difficulty: "Medium",
          desc: "Connected components.",
          examples: [{ input: "[[1,1,0]...]", output: "2" }],
          constraints: [],
          starterCode: "function findCircleNum(M) {\n  return 0;\n}",
          solution:
            "function findCircleNum(M) {\n  let p=M.map((_,i)=>i), count=M.length;\n  const find=x=>p[x]===x?x:p[x]=find(p[x]);\n  for(let i=0; i<M.length; i++){\n    for(let j=i+1; j<M.length; j++){\n      if(M[i][j] && find(i)!==find(j)) { p[find(i)]=find(j); count--; }\n    }\n  }\n  return count;\n}",
          interviewQs: [{ q: "Time?", a: "N^2 approx" }],
        },

        "Implement Trie (Prefix Tree)": {
          difficulty: "Medium",
          desc: "Insert, Search, StartsWith.",
          examples: [{ input: "insert(apple)", output: "null" }],
          constraints: [],
          starterCode: "class Trie {}",
          solution:
            "class TrieNode{constructor(){this.c={};this.end=false}}\nclass Trie{\n  constructor(){this.root=new TrieNode()}\n  insert(w){let n=this.root;for(let c of w){if(!n.c[c])n.c[c]=new TrieNode();n=n.c[c]}n.end=true}\n}",
          interviewQs: [{ q: "Complexity?", a: "O(L)" }],
        },

        "Next Greater Element I": {
          difficulty: "Easy",
          desc: "Next greater in nums2.",
          examples: [{ input: "[4,1,2], [1,3,4,2]", output: "[-1,3,-1]" }],
          constraints: [],
          starterCode: "function nextGreater(n1, n2) {\n  return [];\n}",
          solution:
            "function nextGreater(n1, n2) {\n  let m=new Map(), s=[];\n  for(let n of n2){\n    while(s.length && n>s[s.length-1]) m.set(s.pop(), n);\n    s.push(n);\n  }\n  return n1.map(n=>m.get(n)||-1);\n}",
          interviewQs: [{ q: "Why stack?", a: "Decreasing monotonic" }],
        },

        "Number of Islands": {
          difficulty: "Medium",
          desc: "Count islands '1'.",
          examples: [{ input: "grid", output: "1" }],
          constraints: [],
          starterCode: "function numIslands(grid) {\n  return 0;\n}",
          solution:
            "function numIslands(grid) {\n  let c=0;\n  const dfs=(i,j)=>{\n    if(i<0||j<0||i>=grid.length||j>=grid[0].length||grid[i][j]==='0')return;\n    grid[i][j]='0';\n    dfs(i+1,j);dfs(i-1,j);dfs(i,j+1);dfs(i,j-1);\n  };\n  for(let i=0;i<grid.length;i++)\n    for(let j=0;j<grid[0].length;j++)\n      if(grid[i][j]==='1'){c++;dfs(i,j);}\n  return c;\n}",
          interviewQs: [{ q: "BFS vs DFS?", a: "Both work" }],
        },

        "N-Queens": {
          difficulty: "Hard",
          desc: "Place N queens.",
          examples: [{ input: "n=4", output: "..." }],
          constraints: [],
          starterCode: "function solveNQueens(n) {\n  return [];\n}",
          solution:
            "// Backtracking with sets for cols, diag1, diag2\n// Recursive function place(row)",
          interviewQs: [{ q: "Time?", a: "N!" }],
        },
      };

      let activePatternId = 1;
      let currentFilter = "All";
      let activeTab = "desc";
      let allExpanded = false; // Default collapsed state

      // --- GENERATOR FALLBACK ---
      function getProblemDetails(problemName) {
        if (problemsDB[problemName]) {
          const p = problemsDB[problemName];
          return {
            title: problemName,
            difficulty: p.difficulty,
            desc: p.desc,
            examples: p.examples,
            constraints: p.constraints || [],
            starterCode: p.starterCode,
            solution: p.solution,
            interviewQs: p.interviewQs || [],
          };
        }
        // Generic Fallback
        return {
          title: problemName,
          difficulty: "Medium",
          desc: `<p>Problem details for <strong>${problemName}</strong>.</p>`,
          examples: [{ input: "n=5", output: "res" }],
          constraints: ["N<=10^5"],
          starterCode: `function solve() { console.log("Fallback"); return true; }`,
          solution: `function solve() { // Optimal solution \n return true; }`,
          interviewQs: [{ q: "Complexity?", a: "O(N)" }],
        };
      }

      // --- INIT ---
      function init() {
        loadProgress();
        renderSidebar();
        renderDetail(activePatternId);
        handleResize();
        window.addEventListener("resize", handleResize);
      }

      function handleResize() {
        if (window.innerWidth >= 768) {
          document
            .getElementById("sidebar-panel")
            .classList.remove("hidden", "absolute");
          document.getElementById("main-panel").classList.remove("hidden");
        }
      }
      function showMobileSidebar() {
        document.getElementById("sidebar-panel").classList.remove("hidden");
        document.getElementById("main-panel").classList.add("hidden");
      }
      function showMobileDetail() {
        if (window.innerWidth < 768) {
          document.getElementById("sidebar-panel").classList.add("hidden");
          document.getElementById("main-panel").classList.remove("hidden");
        }
      }

      // --- SIDEBAR LOGIC ---
      function toggleAllPhases() {
        allExpanded = !allExpanded;
        const icon = document.getElementById("toggle-all-icon");
        icon.className = allExpanded
          ? "fa-solid fa-compress"
          : "fa-solid fa-expand";

        phases.forEach((phase) => {
          const content = document.getElementById(`content-${phase.id}`);
          const chevron = document.getElementById(`icon-${phase.id}`);
          if (allExpanded) {
            content.classList.remove("hidden");
            chevron.classList.remove("-rotate-90");
          } else {
            content.classList.add("hidden");
            chevron.classList.add("-rotate-90");
          }
        });
      }

      function togglePhase(id) {
        const c = document.getElementById(`content-${id}`);
        const i = document.getElementById(`icon-${id}`);
        c.classList.toggle("hidden");
        i.classList.toggle("-rotate-90");
      }

      function getPhaseProgress(phaseId) {
        const phasePatterns = patterns.filter((p) => p.phase === phaseId);
        if (phasePatterns.length === 0) return 0;
        let total = 0,
          solved = 0;
        phasePatterns.forEach((pat) => {
          total += pat.problems.length;
          pat.problems.forEach((_, i) => {
            if (localStorage.getItem(`chk-${pat.id}-${i}`) === "true") solved++;
          });
        });
        return total === 0 ? 0 : Math.round((solved / total) * 100);
      }

      function renderSidebar() {
        const container = document.getElementById("sidebar-content");
        let html = "";
        phases.forEach((phase) => {
          const phasePatterns = patterns.filter((p) => p.phase === phase.id);
          if (phasePatterns.length === 0) return;
          const phaseProgress = getPhaseProgress(phase.id);
          const progressColor =
            phaseProgress === 100
              ? "text-emerald-400"
              : phaseProgress > 0
              ? "text-blue-400"
              : "text-slate-500";

          // By default, phases are collapsed (hidden) and icons rotated
          const displayClass = allExpanded ? "" : "hidden";
          const rotateClass = allExpanded ? "" : "-rotate-90";

          html += `<div class="mb-4"><button onclick="togglePhase('${phase.id}')" class="w-full flex items-center justify-between px-2 py-2 mb-1 text-xs font-bold text-slate-500 uppercase hover:bg-slate-800 rounded transition-colors group"><div class="flex items-center gap-2"><span>${phase.title}</span><span class="text-[10px] ${progressColor} bg-slate-800 px-1.5 py-0.5 rounded border border-slate-700">${phaseProgress}%</span></div><i id="icon-${phase.id}" class="fa-solid fa-chevron-down transition-transform duration-200 ${rotateClass}"></i></button><div id="content-${phase.id}" class="space-y-1 transition-all duration-300 origin-top ${displayClass}">`;

          phasePatterns.forEach((pat) => {
            const isActive = pat.id === activePatternId;
            const progress = getPatternProgress(pat);
            let statusColor = "bg-slate-700";
            if (progress > 0) statusColor = "bg-blue-500";
            if (progress === 100) statusColor = "bg-emerald-500";
            html += `<div onclick="selectPattern(${
              pat.id
            })" class="group cursor-pointer rounded-lg p-2.5 transition-all border border-transparent hover:bg-slate-700/50 ${
              isActive ? "active-card bg-slate-700/30" : ""
            }"><div class="flex justify-between items-center mb-1"><span class="text-xs font-medium truncate ${
              isActive
                ? "text-blue-400"
                : "text-slate-300 group-hover:text-white"
            }">${
              pat.name
            }</span><span class="text-[10px] text-slate-500 ml-2">${Math.round(
              progress
            )}%</span></div><div class="w-full h-1 bg-slate-800 rounded-full overflow-hidden"><div class="h-full ${statusColor} transition-all duration-500" style="width: ${progress}%"></div></div></div>`;
          });
          html += `</div></div>`;
        });
        container.innerHTML = html;
        updateGlobalProgress();
      }

      function renderDetail(id) {
        const pat = patterns.find((p) => p.id === id);
        if (!pat) return;
        const phase = phases.find((ph) => ph.id === pat.phase);
        const mainArea = document.getElementById("main-panel");
        mainArea.innerHTML = `
                <header class="h-16 border-b border-slate-700 flex items-center justify-between px-4 md:px-8 bg-[#0f172a]/90 backdrop-blur z-10 shrink-0">
                    <div class="flex items-center gap-4 overflow-hidden"><button onclick="showMobileSidebar()" class="md:hidden text-slate-400 hover:text-white"><i class="fa-solid fa-arrow-left"></i></button><div><div class="flex items-center gap-2 text-xs text-slate-500 mb-1"><span class="hidden md:inline">${
                      phase.title
                    }</span><i class="fa-solid fa-chevron-right text-[8px] hidden md:inline"></i><span>Pattern ${
          pat.id
        }</span></div><h1 class="text-lg md:text-xl font-bold text-white truncate">${
          pat.name
        }</h1></div></div>
                    <a href="https://leetcode.com/problemset/all/" target="_blank" class="px-4 py-2 bg-slate-800 hover:bg-slate-700 text-slate-300 text-xs font-semibold rounded border border-slate-600 transition-colors">LeetCode <i class="fa-solid fa-external-link-alt ml-2"></i></a>
                </header>
                <div class="flex-1 overflow-y-auto p-4 md:p-8 scroll-smooth" id="detail-content">
                    <div class="max-w-4xl mx-auto fade-in pb-20">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                            <div class="bg-[#1e293b] border border-slate-700 rounded-xl p-6 shadow-sm"><div class="flex items-center gap-2 mb-4 text-blue-400"><i class="fa-regular fa-lightbulb"></i><h2 class="text-sm font-bold uppercase tracking-wide">The Strategy</h2></div><p class="text-slate-300 text-sm leading-relaxed mb-4">${
                              pat.desc
                            }</p><div class="bg-slate-800/50 rounded-lg p-3 border-l-2 border-blue-500"><p class="text-xs text-slate-400 italic">"${
          pat.strategy
        }"</p></div></div>
                            <div class="bg-[#0f172a] border border-slate-700 rounded-xl overflow-hidden shadow-sm flex flex-col"><div class="bg-[#1e293b] px-4 py-2 border-b border-slate-700 flex justify-between items-center"><span class="text-xs font-mono text-slate-400">Anchor Code</span><span class="text-[10px] bg-slate-700 text-slate-300 px-2 py-0.5 rounded">Pseudo-code</span></div><div class="p-4 overflow-x-auto custom-scroll"><pre><code class="language-javascript">${
                              pat.anchor.logic
                            }</code></pre></div></div>
                        </div>
                        <div class="bg-[#1e293b] border border-slate-700 rounded-xl overflow-hidden mb-8"><div class="px-6 py-4 border-b border-slate-700 flex flex-col md:flex-row md:justify-between md:items-center gap-4"><div class="flex items-center gap-4"><h2 class="font-bold text-white flex items-center gap-2"><i class="fa-solid fa-list-check text-slate-400"></i> Practice Problems</h2><span class="text-xs text-slate-500">${
                          pat.problems.length
                        } Challenges</span></div><div><select id="filter-select" onchange="filterProblems(${id})" class="bg-slate-800 text-slate-300 text-xs border border-slate-600 rounded px-2 py-1 outline-none focus:border-blue-500 w-full md:w-auto"><option value="All">All Levels</option><option value="Easy">Easy</option><option value="Medium">Medium</option><option value="Hard">Hard</option></select></div></div><div class="divide-y divide-slate-700/50" id="problem-list-container">${renderProblemList(
          pat
        )}</div></div>
                    </div>
                </div>
                <div class="h-16 border-t border-slate-700 bg-[#1e293b] flex items-center justify-between px-4 md:px-8 shrink-0" id="detail-footer"></div>`;
        Prism.highlightAllUnder(document.getElementById("detail-content"));
        renderFooterNav(id);
      }

      function renderFooterNav(id) {
        const footer = document.getElementById("detail-footer");
        const prevPat = patterns.find((p) => p.id === id - 1);
        const nextPat = patterns.find((p) => p.id === id + 1);
        footer.innerHTML = `<div>${
          prevPat
            ? `<button onclick="selectPattern(${prevPat.id})" class="nav-btn"><i class="fa-solid fa-arrow-left"></i> <span class="hidden md:inline">${prevPat.name}</span><span class="md:hidden">Prev</span></button>`
            : ""
        }</div><div>${
          nextPat
            ? `<button onclick="selectPattern(${nextPat.id})" class="nav-btn"><span class="hidden md:inline">${nextPat.name}</span><span class="md:hidden">Next</span> <i class="fa-solid fa-arrow-right"></i></button>`
            : ""
        }</div>`;
      }

      function renderProblemList(pat) {
        const difficulties = ["Easy", "Medium", "Hard"];
        const filtered = pat.problems
          .map((p, i) => ({
            name: p,
            difficulty: difficulties[i % 3],
            index: i,
          }))
          .filter(
            (p) => currentFilter === "All" || p.difficulty === currentFilter
          );
        if (filtered.length === 0)
          return `<div class="p-6 text-center text-slate-500 text-sm">No problems found for this filter.</div>`;
        return filtered
          .map((probObj) => {
            const uid = `chk-${pat.id}-${probObj.index}`;
            const isChecked = localStorage.getItem(uid) === "true";
            const rowClass = isChecked
              ? "bg-emerald-900/10 border-l-2 border-emerald-500"
              : "hover:bg-slate-700/30 border-l-2 border-transparent";
            const textClass = isChecked
              ? "text-emerald-400 opacity-80"
              : "text-slate-200 group-hover:text-blue-400";
            return `<div class="group flex items-center px-4 md:px-6 py-4 transition-all cursor-pointer ${rowClass}" onclick="openProblem('${
              probObj.name
            }', ${pat.id}, ${
              probObj.index
            })"><div onclick="event.stopPropagation()" class="shrink-0 checkbox-wrapper"><label class="relative flex items-center cursor-pointer"><input type="checkbox" id="${uid}" onchange="toggleCheck('${uid}', ${
              pat.id
            })" class="peer sr-only custom-checkbox" ${
              isChecked ? "checked" : ""
            }><div class="w-5 h-5 border-2 border-slate-500 rounded transition-all flex items-center justify-center"><i class="fa-solid fa-check text-white text-[12px] opacity-0 peer-checked:opacity-100"></i></div></label></div><div class="ml-4 flex-1 min-w-0"><span class="text-sm font-medium transition-colors truncate block ${textClass}">${
              probObj.name
            }</span></div><div class="flex items-center gap-3 shrink-0"><span class="text-[10px] border px-2 py-0.5 rounded-full badge-${
              probObj.difficulty
            }">${
              probObj.difficulty
            }</span><div class="opacity-0 group-hover:opacity-100 transition-opacity hidden md:block"><button class="text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 px-3 py-1.5 rounded font-medium flex items-center gap-2"><i class="fa-solid fa-code"></i> Solve</button></div></div></div>`;
          })
          .join("");
      }

      function filterProblems(patId) {
        currentFilter = document.getElementById("filter-select").value;
        const pat = patterns.find((p) => p.id === patId);
        document.getElementById("problem-list-container").innerHTML =
          renderProblemList(pat);
      }

      function openProblem(problemName, patId, probIndex) {
        const data = getProblemDetails(problemName);
        window.currentProblemData = data;
        const mainArea = document.getElementById("main-panel");
        const uid = `chk-${patId}-${probIndex}`;
        const isChecked = localStorage.getItem(uid) === "true";
        mainArea.innerHTML = `
                <header class="h-14 border-b border-slate-700 flex items-center justify-between px-4 md:px-6 bg-[#1e293b] z-10 shrink-0">
                    <div class="flex items-center gap-4 overflow-hidden"><button onclick="renderDetail(${patId})" class="text-slate-400 hover:text-white transition-colors text-sm flex items-center gap-2 shrink-0"><i class="fa-solid fa-arrow-left"></i> <span class="hidden md:inline">Back</span></button><div class="h-4 w-px bg-slate-600 shrink-0"></div><h1 class="font-bold text-slate-200 text-sm truncate">${
          data.title
        }</h1></div>
                    <div class="flex gap-2 items-center shrink-0"><div class="hidden md:flex items-center gap-2 text-xs text-slate-400 bg-slate-800 px-3 py-1.5 rounded border border-slate-600"><i class="fa-brands fa-js text-yellow-400"></i> JS Only</div><button id="solver-check-btn" onclick="toggleSolverCheck('${uid}', ${patId})" class="px-3 py-1.5 text-xs border border-slate-600 rounded transition-colors flex items-center gap-2 ${
          isChecked
            ? "bg-emerald-900/30 text-emerald-400 border-emerald-800"
            : "text-slate-300 hover:bg-slate-700"
        }"><i class="fa-solid fa-check ${
          isChecked ? "" : "opacity-50"
        }"></i> <span class="hidden md:inline">${
          isChecked ? "Completed" : "Mark Done"
        }</span></button><button onclick="runCode()" class="px-3 py-1.5 text-xs bg-green-600 hover:bg-green-500 text-white rounded transition-colors flex items-center gap-2 font-bold shadow-lg shadow-green-500/20"><i class="fa-solid fa-play"></i> <span class="hidden md:inline">Run</span></button></div>
                </header>
                <div class="flex-1 flex flex-col md:flex-row overflow-hidden">
                    <div class="w-full md:w-1/2 flex flex-col border-r border-slate-700 bg-[#0f172a] h-1/2 md:h-full">
                        <div class="flex border-b border-slate-700 bg-[#1e293b]"><button onclick="switchTab('desc')" id="tab-desc" class="flex-1 px-4 py-2 text-sm font-medium border-b-2 border-blue-400 text-blue-400 bg-[#0f172a]">Description</button><button onclick="switchTab('interview')" id="tab-interview" class="flex-1 px-4 py-2 text-sm font-medium border-b-2 border-transparent text-slate-400 hover:text-slate-200">Interview</button><button onclick="switchTab('solution')" id="tab-solution" class="flex-1 px-4 py-2 text-sm font-medium border-b-2 border-transparent text-slate-400 hover:text-slate-200">Solution</button></div>
                        <div class="flex-1 overflow-y-auto p-6 custom-scroll" id="tab-content"></div>
                    </div>
                    <div class="w-full md:w-1/2 flex flex-col bg-[#1e1e1e] h-1/2 md:h-full border-t md:border-t-0 border-slate-700">
                        <div class="h-8 bg-[#1e1e1e] border-b border-[#333] flex items-center px-2 shrink-0"><div class="px-3 h-full flex items-center bg-[#1e1e1e] text-xs text-slate-300 border-t-2 border-blue-500 font-medium"><i class="fa-brands fa-js text-orange-500 mr-2"></i> Solution.js</div></div>
                        <div class="editor-container flex-1 relative"><div class="editor-layer" style="z-index:0"><pre><code id="highlighting-content" class="language-javascript"></code></pre></div><textarea id="code-editor" class="editor-layer" spellcheck="false" oninput="updateHighlight(this.value)" onscroll="syncScroll(this)">${
                          data.starterCode
                        }</textarea></div>
                        <div class="h-40 border-t border-slate-700 bg-[#0f172a] p-3 font-mono text-xs overflow-y-auto shrink-0" id="console-output"><div class="text-slate-500">Console Output...</div></div>
                    </div>
                </div>`;
        updateHighlight(data.starterCode);
        switchTab("desc");
        showMobileDetail();
      }

      function updateHighlight(text) {
        let result_element = document.querySelector("#highlighting-content");
        if (!result_element) return;
        if (text[text.length - 1] == "\n") text += " ";
        result_element.innerHTML = text
          .replace(new RegExp("&", "g"), "&amp;")
          .replace(new RegExp("<", "g"), "&lt;");
        Prism.highlightElement(result_element);
      }
      function syncScroll(element) {
        let result_element = document.querySelector("#highlighting-content");
        if (result_element) {
          result_element.parentElement.parentElement.scrollTop =
            element.scrollTop;
          result_element.parentElement.parentElement.scrollLeft =
            element.scrollLeft;
        }
      }

      function switchTab(tabName) {
        activeTab = tabName;
        const data = window.currentProblemData;
        const container = document.getElementById("tab-content");
        ["desc", "interview", "solution"].forEach((t) => {
          const btn = document.getElementById(`tab-${t}`);
          btn.className =
            t === tabName
              ? "flex-1 px-4 py-2 text-sm font-medium border-b-2 border-blue-400 text-blue-400 bg-[#0f172a]"
              : "flex-1 px-4 py-2 text-sm font-medium border-b-2 border-transparent text-slate-400 hover:text-slate-200";
        });
        if (tabName === "desc") {
          container.innerHTML = `<div class="text-slate-300 text-sm leading-relaxed">${
            data.desc
          }<div class="mt-6 space-y-4">${data.examples
            .map(
              (ex, i) =>
                `<div><p class="font-bold text-slate-200 mb-2">Example ${
                  i + 1
                }:</p><div class="bg-slate-800/50 p-3 rounded border-l-2 border-slate-600 font-mono text-xs"><p><span class="text-slate-400">Input:</span> ${
                  ex.input
                }</p><p><span class="text-slate-400">Output:</span> ${
                  ex.output
                }</p>${
                  ex.explanation
                    ? `<p><span class="text-slate-400">Explanation:</span> ${ex.explanation}</p>`
                    : ""
                }</div></div>`
            )
            .join(
              ""
            )}</div><div class="mt-8"><p class="font-bold text-slate-200 mb-2">Constraints:</p><ul class="list-disc pl-5 space-y-1 text-slate-400 text-xs">${data.constraints
            .map((c) => `<li>${c}</li>`)
            .join("")}</ul></div></div>`;
        } else if (tabName === "interview") {
          container.innerHTML = `<div class="space-y-4"><h3 class="font-bold text-slate-200 mb-4 flex items-center gap-2"><i class="fa-solid fa-user-tie text-purple-400"></i> Common Questions</h3>${data.interviewQs
            .map(
              (iq, idx) =>
                `<div class="border border-slate-700 rounded bg-slate-800/30 overflow-hidden"><button onclick="document.getElementById('ans-${idx}').classList.toggle('hidden')" class="w-full text-left px-4 py-3 text-xs font-medium text-slate-300 hover:bg-slate-800 transition-colors flex justify-between items-center">${iq.q}<i class="fa-solid fa-chevron-down text-slate-500"></i></button><div id="ans-${idx}" class="hidden px-4 py-3 bg-slate-900/50 border-t border-slate-700 text-xs text-slate-400">${iq.a}</div></div>`
            )
            .join("")}</div>`;
        } else if (tabName === "solution") {
          container.innerHTML = `<div class="space-y-4"><h3 class="font-bold text-slate-200">Optimal Solution (JavaScript)</h3><p class="text-xs text-slate-400">Time Complexity: O(N) | Space Complexity: O(1)</p><div class="bg-[#1e1e1e] p-4 rounded border border-slate-700 overflow-x-auto"><pre><code class="language-javascript">${data.solution}</code></pre></div></div>`;
          Prism.highlightAllUnder(container);
        }
      }

      function runCode() {
        const consoleDiv = document.getElementById("console-output");
        const code = document.getElementById("code-editor").value;
        consoleDiv.innerHTML = `<div class="text-yellow-500"><i class="fa-solid fa-circle-notch fa-spin"></i> Running...</div>`;
        setTimeout(() => {
          try {
            let logs = [];
            const mockConsole = {
              log: (...args) =>
                logs.push(
                  args
                    .map((a) => (typeof a === "object" ? JSON.stringify(a) : a))
                    .join(" ")
                ),
              error: (...args) =>
                logs.push(
                  `<span class="text-red-400">${args.join(" ")}</span>`
                ),
            };
            new Function("console", code)(mockConsole);
            let outputHtml = `<div class="text-emerald-400 font-bold mb-2">Execution Complete</div>`;
            if (logs.length > 0)
              outputHtml +=
                `<div class="text-slate-300 mb-1 border-b border-slate-700 pb-1">Console Output:</div>` +
                logs
                  .map(
                    (l) => `<div class="font-mono text-slate-400">> ${l}</div>`
                  )
                  .join("");
            else
              outputHtml += `<div class="text-slate-500 italic">No output log found.</div>`;
            const data = window.currentProblemData;
            if (data && data.examples && data.examples[0])
              outputHtml += `<div class="mt-4 pt-2 border-t border-slate-700"><div class="text-blue-400 text-xs font-bold">Expected Output (Example 1):</div><div class="font-mono text-slate-400 text-xs">${data.examples[0].output}</div></div>`;
            consoleDiv.innerHTML = outputHtml;
          } catch (e) {
            consoleDiv.innerHTML = `<div class="text-red-500 font-bold mb-2">Runtime Error</div><div class="text-red-300">${e.message}</div>`;
          }
        }, 500);
      }

      function selectPattern(id) {
        activePatternId = id;
        renderSidebar();
        renderDetail(id);
        showMobileDetail();
      }

      function toggleCheck(uid, patId) {
        localStorage.setItem(uid, document.getElementById(uid).checked);
        renderSidebar();
        const row = document.getElementById(uid).closest(".group");
        if (document.getElementById(uid).checked) {
          row.classList.add(
            "bg-emerald-900/10",
            "border-l-2",
            "border-emerald-500"
          );
          row
            .querySelector("span")
            .classList.add("text-emerald-400", "opacity-80");
        } else {
          row.classList.remove(
            "bg-emerald-900/10",
            "border-l-2",
            "border-emerald-500"
          );
          row
            .querySelector("span")
            .classList.remove("text-emerald-400", "opacity-80");
        }
      }
      function toggleSolverCheck(uid, patId) {
        const wasChecked = localStorage.getItem(uid) === "true";
        localStorage.setItem(uid, !wasChecked);
        renderSidebar();
        const btn = document.getElementById("solver-check-btn");
        if (!wasChecked) {
          btn.className =
            "px-3 py-1.5 text-xs border border-emerald-800 bg-emerald-900/30 text-emerald-400 rounded transition-colors flex items-center gap-2";
          btn.innerHTML =
            '<i class="fa-solid fa-check"></i> <span class="hidden md:inline">Completed</span>';
        } else {
          btn.className =
            "px-3 py-1.5 text-xs border border-slate-600 text-slate-300 hover:bg-slate-700 rounded transition-colors flex items-center gap-2";
          btn.innerHTML =
            '<i class="fa-solid fa-check opacity-50"></i> <span class="hidden md:inline">Mark Done</span>';
        }
      }
      function getPatternProgress(pat) {
        const total = pat.problems.length;
        if (total === 0) return 0;
        let completed = 0;
        pat.problems.forEach((_, i) => {
          if (localStorage.getItem(`chk-${pat.id}-${i}`) === "true")
            completed++;
        });
        return (completed / total) * 100;
      }
      function updateGlobalProgress() {
        let t = 0,
          s = 0;
        patterns.forEach((pat) => {
          t += pat.problems.length;
          pat.problems.forEach((_, i) => {
            if (localStorage.getItem(`chk-${pat.id}-${i}`) === "true") s++;
          });
        });
        const p = t === 0 ? 0 : Math.round((s / t) * 100);
        document.getElementById(
          "global-progress-text"
        ).innerText = `${p}% Complete`;
        document.getElementById("global-progress-bar").style.width = `${p}%`;
      }
      function loadProgress() {}
      function resetData() {
        if (confirm("Clear all?")) {
          localStorage.clear();
          init();
        }
      }

      init();
      //       // --- REAL PROBLEM DATABASE ---
      //       const problemsDBb = {
      //         "Maximum Sum Subarray of Size K": {
      //           difficulty: "Easy",
      //           desc: `<p class="mb-4">Given an array of positive numbers and a positive number k, find the maximum sum of any contiguous subarray of size k.</p>`,
      //           examples: [
      //             {
      //               input: "nums = [2, 1, 5, 1, 3, 2], k = 3",
      //               output: "9",
      //               explanation: "Subarray with max sum is [5, 1, 3].",
      //             },
      //           ],
      //           constraints: ["1 <= k <= nums.length"],
      //           starterCode: `function maxSubArray(k, nums) {
      //     // Write your code here
      //     console.log("Processing:", nums);
      //     return 0;
      // }
      // // Test
      // maxSubArray(3, [2, 1, 5, 1, 3, 2]);`,
      //           solution: `function maxSubArray(k, nums) {
      //     let maxSum = 0, windowSum = 0, windowStart = 0;
      //     for (let windowEnd = 0; windowEnd < nums.length; windowEnd++) {
      //         windowSum += nums[windowEnd];
      //         if (windowEnd >= k - 1) {
      //             maxSum = Math.max(maxSum, windowSum);
      //             windowSum -= nums[windowStart];
      //             windowStart += 1;
      //         }
      //     }
      //     return maxSum;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Can you handle negative numbers?",
      //               a: "Yes, logic holds, but initialize maxSum to -Infinity.",
      //             },
      //           ],
      //         },
      //         "Pair with Target Sum": {
      //           difficulty: "Easy",
      //           desc: `<p class="mb-4">Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.</p>`,
      //           examples: [
      //             {
      //               input: "nums = [1, 2, 3, 4, 6], target = 6",
      //               output: "[1, 3]",
      //               explanation: "nums[1] + nums[3] = 2 + 4 = 6",
      //             },
      //           ],
      //           constraints: ["Array is sorted"],
      //           starterCode: `function pairWithTargetSum(nums, target) {
      //     // Write your code here
      //     return [-1, -1];
      // }
      // pairWithTargetSum([1, 2, 3, 4, 6], 6);`,
      //           solution: `function pairWithTargetSum(nums, target) {
      //     let left = 0, right = nums.length - 1;
      //     while (left < right) {
      //         const currentSum = nums[left] + nums[right];
      //         if (currentSum === target) return [left, right];
      //         if (currentSum < target) left++;
      //         else right--;
      //     }
      //     return [-1, -1];
      // }`,
      //           interviewQs: [
      //             {
      //               q: "What if array is not sorted?",
      //               a: "Use a HashMap (O(N) space) or Sort first (O(N log N)).",
      //             },
      //           ],
      //         },
      //         "Linked List Cycle": {
      //           difficulty: "Easy",
      //           desc: `<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>`,
      //           examples: [{ input: "head = [3,2,0,-4], pos = 1", output: "true" }],
      //           constraints: ["pos is -1 or valid index"],
      //           starterCode: `function hasCycle(head) {
      //     // Write code
      //     return false;
      // }`,
      //           solution: `function hasCycle(head) {
      //     let slow = head, fast = head;
      //     while (fast !== null && fast.next !== null) {
      //         slow = slow.next;
      //         fast = fast.next.next;
      //         if (slow === fast) return true;
      //     }
      //     return false;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Can you calculate the cycle length?",
      //               a: "Yes, once slow/fast meet, freeze slow and move fast until they meet again.",
      //             },
      //           ],
      //         },
      //         "Merge Intervals": {
      //           difficulty: "Medium",
      //           desc: "<p>Given an array of intervals where intervals[i] = [start, end], merge all overlapping intervals.</p>",
      //           examples: [
      //             {
      //               input: "[[1,3],[2,6],[8,10],[15,18]]",
      //               output: "[[1,6],[8,10],[15,18]]",
      //             },
      //           ],
      //           constraints: ["intervals.length >= 1"],
      //           starterCode: `function merge(intervals) {
      //     // Sort and merge
      //     return [];
      // }`,
      //           solution: `function merge(intervals) {
      //     if (intervals.length < 2) return intervals;
      //     intervals.sort((a, b) => a[0] - b[0]);
      //     const merged = [intervals[0]];
      //     for (let i = 1; i < intervals.length; i++) {
      //         const prev = merged[merged.length - 1];
      //         const curr = intervals[i];
      //         if (curr[0] <= prev[1]) {
      //             prev[1] = Math.max(prev[1], curr[1]);
      //         } else {
      //             merged.push(curr);
      //         }
      //     }
      //     return merged;
      // }`,
      //           interviewQs: [
      //             { q: "Time Complexity?", a: "O(N log N) due to sorting." },
      //           ],
      //         },
      //         "Missing Number": {
      //           difficulty: "Easy",
      //           desc: "<p>Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing.</p>",
      //           examples: [{ input: "[3,0,1]", output: "2" }],
      //           constraints: ["n == nums.length"],
      //           starterCode: `function missingNumber(nums) {
      //     // Cyclic sort or Math approach
      //     return -1;
      // }`,
      //           solution: `function missingNumber(nums) {
      //     let i = 0;
      //     const n = nums.length;
      //     while (i < n) {
      //         const j = nums[i];
      //         if (j < n && nums[i] !== nums[j]) {
      //             [nums[i], nums[j]] = [nums[j], nums[i]];
      //         } else {
      //             i++;
      //         }
      //     }
      //     for (i = 0; i < n; i++) {
      //         if (nums[i] !== i) return i;
      //     }
      //     return n;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Can you do it with XOR?",
      //               a: "Yes, XOR all indices and all values. The result is the missing number.",
      //             },
      //           ],
      //         },
      //         "Reverse Linked List": {
      //           difficulty: "Easy",
      //           desc: "<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>",
      //           examples: [{ input: "head = [1,2,3,4,5]", output: "[5,4,3,2,1]" }],
      //           constraints: ["Number of nodes is [0, 5000]"],
      //           starterCode: `function reverseList(head) {
      //     // Iterative approach
      //     return null;
      // }`,
      //           solution: `function reverseList(head) {
      //     let prev = null;
      //     let curr = head;
      //     while (curr !== null) {
      //         let nextTemp = curr.next;
      //         curr.next = prev;
      //         prev = curr;
      //         curr = nextTemp;
      //     }
      //     return prev;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Can you do it recursively?",
      //               a: "Yes, reverse rest of list, then set head.next.next = head; head.next = null.",
      //             },
      //           ],
      //         },
      //         "Binary Tree Level Order Traversal": {
      //           difficulty: "Medium",
      //           desc: "<p>Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p>",
      //           examples: [
      //             {
      //               input: "root = [3,9,20,null,null,15,7]",
      //               output: "[[3],[9,20],[15,7]]",
      //             },
      //           ],
      //           constraints: ["Node values are unique"],
      //           starterCode: `function levelOrder(root) {
      //     // Use a Queue
      //     return [];
      // }`,
      //           solution: `function levelOrder(root) {
      //     if (!root) return [];
      //     const result = [];
      //     const queue = [root];
      //     while (queue.length > 0) {
      //         const levelSize = queue.length;
      //         const currentLevel = [];
      //         for (let i = 0; i < levelSize; i++) {
      //             const currentNode = queue.shift();
      //             currentLevel.push(currentNode.val);
      //             if (currentNode.left) queue.push(currentNode.left);
      //             if (currentNode.right) queue.push(currentNode.right);
      //         }
      //         result.push(currentLevel);
      //     }
      //     return result;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Space Complexity?",
      //               a: "O(W) where W is maximum width of the tree.",
      //             },
      //           ],
      //         },
      //         "Path Sum": {
      //           difficulty: "Easy",
      //           desc: "<p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>",
      //           examples: [
      //             {
      //               input:
      //                 "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
      //               output: "true",
      //             },
      //           ],
      //           constraints: ["-1000 <= Node.val <= 1000"],
      //           starterCode: `function hasPathSum(root, targetSum) {
      //     // DFS recursion
      //     return false;
      // }`,
      //           solution: `function hasPathSum(root, targetSum) {
      //     if (!root) return false;
      //     if (!root.left && !root.right && targetSum === root.val) return true;
      //     return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Iterative solution?",
      //               a: "Yes, use a stack storing pairs of (node, current_sum).",
      //             },
      //           ],
      //         },
      //         Subsets: {
      //           difficulty: "Medium",
      //           desc: "<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>",
      //           examples: [
      //             {
      //               input: "nums = [1,2,3]",
      //               output: "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
      //             },
      //           ],
      //           constraints: ["nums contains unique numbers"],
      //           starterCode: `function subsets(nums) {
      //     // Backtracking or Cascading
      //     return [];
      // }`,
      //           solution: `function subsets(nums) {
      //     const result = [[]];
      //     for (const num of nums) {
      //         const n = result.length;
      //         for (let i = 0; i < n; i++) {
      //             result.push([...result[i], num]);
      //         }
      //     }
      //     return result;
      // }`,
      //           interviewQs: [
      //             { q: "Complexity?", a: "Time: O(N * 2^N), Space: O(N * 2^N)." },
      //           ],
      //         },
      //         "Binary Search": {
      //           difficulty: "Easy",
      //           desc: "<p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p>",
      //           examples: [
      //             { input: "nums = [-1,0,3,5,9,12], target = 9", output: "4" },
      //           ],
      //           constraints: ["nums is sorted unique"],
      //           starterCode: `function search(nums, target) {
      //     // O(log n)
      //     return -1;
      // }`,
      //           solution: `function search(nums, target) {
      //     let left = 0, right = nums.length - 1;
      //     while (left <= right) {
      //         const mid = Math.floor(left + (right - left) / 2);
      //         if (nums[mid] === target) return mid;
      //         if (nums[mid] < target) left = mid + 1;
      //         else right = mid - 1;
      //     }
      //     return -1;
      // }`,
      //           interviewQs: [
      //             {
      //               q: "Why l + (r-l)/2?",
      //               a: "To prevent integer overflow in languages with fixed integer sizes (like C++/Java).",
      //             },
      //           ],
      //         },
      //       };
      // Full Pattern List
      // const patternss = [
      //   {
      //     id: 1,
      //     phase: "p1",
      //     name: "Sliding Window",
      //     desc: "Find subarrays satisfying a condition.",
      //     strategy: "Use start/end pointers. Expand end, shrink start.",
      //     anchor: {
      //       logic:
      //         "for(end=0..n) { sum+=arr[end]; while(bad) sum-=arr[start++]; }",
      //     },
      //     problems: [
      //       "Maximum Sum Subarray of Size K",
      //       "Smallest Subarray with a given sum",
      //       "Longest Substring with K Distinct Characters",
      //       "Fruits into Baskets",
      //     ],
      //   },
      //   {
      //     id: 2,
      //     phase: "p1",
      //     name: "Two Pointers",
      //     desc: "Iterate sorted arrays from ends.",
      //     strategy: "Left=0, Right=N-1. Move based on sum comparison.",
      //     anchor: {
      //       logic:
      //         "while(L < R) { if(sum==t) ret; else if(sum<t) L++; else R--; }",
      //     },
      //     problems: [
      //       "Pair with Target Sum",
      //       "Remove Duplicates from Sorted Array",
      //       "Squaring a Sorted Array",
      //       "3Sum",
      //     ],
      //   },
      //   {
      //     id: 3,
      //     phase: "p1",
      //     name: "Fast & Slow Pointers",
      //     desc: "Cycle detection.",
      //     strategy: "Fast moves 2x speed. If meet -> cycle.",
      //     anchor: {
      //       logic:
      //         "fast=head; slow=head; while(fast && fast.next) { fast=fast.next.next; slow=slow.next; if(fast==slow) return true; }",
      //     },
      //     problems: [
      //       "Linked List Cycle",
      //       "Middle of the Linked List",
      //       "Start of Linked List Cycle",
      //       "Happy Number",
      //     ],
      //   },
      //   {
      //     id: 4,
      //     phase: "p1",
      //     name: "Merge Intervals",
      //     desc: "Overlap handling.",
      //     strategy: "Sort by start. If curr.start <= prev.end, merge.",
      //     anchor: {
      //       logic:
      //         "sort(intervals); res=[int[0]]; for(curr in int) { if(curr.s <= prev.e) prev.e = max(prev.e, curr.e); }",
      //     },
      //     problems: [
      //       "Merge Intervals",
      //       "Insert Interval",
      //       "Intervals Intersection",
      //       "Conflicting Appointments",
      //     ],
      //   },
      //   {
      //     id: 5,
      //     phase: "p1",
      //     name: "Cyclic Sort",
      //     desc: "Sort 1..N in O(N).",
      //     strategy: "Swap nums[i] to correct index nums[nums[i]-1].",
      //     anchor: {
      //       logic:
      //         "while(i<n) { j=nums[i]-1; if(nums[i]!=nums[j]) swap(i,j); else i++; }",
      //     },
      //     problems: [
      //       "Missing Number",
      //       "Find All Numbers Disappeared in an Array",
      //       "Find the Duplicate Number",
      //       "Find All Duplicates in an Array",
      //     ],
      //   },
      //   {
      //     id: 6,
      //     phase: "p2",
      //     name: "List Reversal",
      //     desc: "In-place linked list manipulation.",
      //     strategy: "Prev, Curr, Next pointers.",
      //     anchor: {
      //       logic:
      //         "prev=null; while(curr) { next=curr.next; curr.next=prev; prev=curr; curr=next; }",
      //     },
      //     problems: [
      //       "Reverse Linked List",
      //       "Reverse Linked List II",
      //       "Reverse Nodes in k-Group",
      //       "Rotate List",
      //     ],
      //   },
      //   {
      //     id: 7,
      //     phase: "p2",
      //     name: "Tree BFS",
      //     desc: "Level order traversal.",
      //     strategy: "Use a Queue. Process level size.",
      //     anchor: {
      //       logic:
      //         "Q=[root]; while(Q) { len=Q.length; for(i=0..len) { node=Q.shift(); push(left, right); } }",
      //     },
      //     problems: [
      //       "Binary Tree Level Order Traversal",
      //       "Binary Tree Zigzag Level Order Traversal",
      //       "Average of Levels in Binary Tree",
      //       "Minimum Depth of Binary Tree",
      //     ],
      //   },
      //   {
      //     id: 8,
      //     phase: "p2",
      //     name: "Tree DFS",
      //     desc: "Depth first traversal.",
      //     strategy: "Recursion or Stack.",
      //     anchor: {
      //       logic:
      //         "dfs(node) { if(!node) return; dfs(node.left); dfs(node.right); }",
      //     },
      //     problems: [
      //       "Path Sum",
      //       "Path Sum II",
      //       "Path Sum III",
      //       "Sum Root to Leaf Numbers",
      //     ],
      //   },
      //   {
      //     id: 9,
      //     phase: "p2",
      //     name: "Two Heaps",
      //     desc: "Median/Min/Max in stream.",
      //     strategy: "MaxHeap (small half), MinHeap (large half).",
      //     anchor: {
      //       logic:
      //         "push(x); balance(); median = size%2 ? max.peek() : (max.peek()+min.peek())/2;",
      //     },
      //     problems: [
      //       "Find Median from Data Stream",
      //       "Sliding Window Median",
      //       "IPO",
      //       "Find Right Interval",
      //     ],
      //   },
      //   {
      //     id: 10,
      //     phase: "p2",
      //     name: "Subsets",
      //     desc: "Permutations/Combinations.",
      //     strategy: "Backtracking or Cascading.",
      //     anchor: {
      //       logic:
      //         "res=[[]]; for(n in nums) { len=res.length; for(i=0..len) res.push([...res[i], n]); }",
      //     },
      //     problems: [
      //       "Subsets",
      //       "Subsets II",
      //       "Permutations",
      //       "Letter Combinations of a Phone Number",
      //     ],
      //   },
      //   {
      //     id: 11,
      //     phase: "p3",
      //     name: "Binary Search",
      //     desc: "Search in O(logN).",
      //     strategy: "Mid calculation.",
      //     anchor: { logic: "mid=L+(R-L)/2;" },
      //     problems: [
      //       "Binary Search",
      //       "Search Insert Position",
      //       "Search in Rotated Sorted Array",
      //       "Find Peak Element",
      //     ],
      //   },
      //   {
      //     id: 12,
      //     phase: "p3",
      //     name: "Bitwise XOR",
      //     desc: "Unique elements.",
      //     strategy: "XOR properties.",
      //     anchor: { logic: "res ^= num;" },
      //     problems: [
      //       "Single Number",
      //       "Single Number II",
      //       "Hamming Distance",
      //       "Total Hamming Distance",
      //     ],
      //   },
      //   {
      //     id: 13,
      //     phase: "p3",
      //     name: "Top K Elements",
      //     desc: "Heap usage.",
      //     strategy: "MinHeap for Top K.",
      //     anchor: { logic: "heap.push(n); if(size>k) heap.pop();" },
      //     problems: [
      //       "Kth Largest Element in an Array",
      //       "Top K Frequent Elements",
      //       "K Closest Points to Origin",
      //       "Sort Characters By Frequency",
      //     ],
      //   },
      //   {
      //     id: 14,
      //     phase: "p3",
      //     name: "K-way Merge",
      //     desc: "Merge lists.",
      //     strategy: "MinHeap with list pointers.",
      //     anchor: {
      //       logic: "heap.push(list[0]); while(heap) { pop(); push(next); }",
      //     },
      //     problems: [
      //       "Merge K Sorted Lists",
      //       "Kth Smallest Element in a Sorted Matrix",
      //       "Find K Pairs with Smallest Sums",
      //       "Smallest Range Covering Elements from K Lists",
      //     ],
      //   },
      //   {
      //     id: 15,
      //     phase: "p4",
      //     name: "0/1 Knapsack",
      //     desc: "Optimization.",
      //     strategy: "DP Grid.",
      //     anchor: { logic: "dp[i][c] = max(excl, incl + val);" },
      //     problems: [
      //       "Partition Equal Subset Sum",
      //       "Target Sum",
      //       "Last Stone Weight II",
      //       "Ones and Zeroes",
      //     ],
      //   },
      //   {
      //     id: 16,
      //     phase: "p4",
      //     name: "Unbounded Knapsack",
      //     desc: "Infinite items.",
      //     strategy: "DP linear scan.",
      //     anchor: { logic: "dp[c] = max(dp[c], dp[c-w] + val);" },
      //     problems: [
      //       "Coin Change",
      //       "Rod Cutting",
      //       "Integer Break",
      //       "Perfect Squares",
      //     ],
      //   },
      //   {
      //     id: 17,
      //     phase: "p4",
      //     name: "Fibonacci",
      //     desc: "Prev state dependency.",
      //     strategy: "Two variables.",
      //     anchor: { logic: "cur = prev1 + prev2;" },
      //     problems: [
      //       "Fibonacci Number",
      //       "Climbing Stairs",
      //       "House Robber",
      //       "Jump Game",
      //     ],
      //   },
      //   {
      //     id: 18,
      //     phase: "p4",
      //     name: "Palindromic Subseq",
      //     desc: "String symmetry.",
      //     strategy: "Check ends match.",
      //     anchor: { logic: "if(s[i]==s[j]) 2+dp[i+1][j-1];" },
      //     problems: [
      //       "Longest Palindromic Substring",
      //       "Longest Palindromic Subsequence",
      //       "Palindromic Substrings",
      //       "Count Different Palindromic Subsequences",
      //     ],
      //   },
      //   {
      //     id: 19,
      //     phase: "p4",
      //     name: "LCS",
      //     desc: "Commonality.",
      //     strategy: "2D DP match.",
      //     anchor: { logic: "if(c1==c2) 1+dp[i-1][j-1];" },
      //     problems: [
      //       "Longest Common Subsequence",
      //       "Edit Distance",
      //       "Distinct Subsequences",
      //       "Shortest Common Supersequence",
      //     ],
      //   },
      //   {
      //     id: 20,
      //     phase: "p5",
      //     name: "Topological Sort",
      //     desc: "Dependencies.",
      //     strategy: "Kahn's Algo.",
      //     anchor: { logic: "inDegree[child]--; if(0) Q.push();" },
      //     problems: [
      //       "Course Schedule",
      //       "Alien Dictionary",
      //       "Sequence Reconstruction",
      //       "Parallel Courses",
      //     ],
      //   },
      //   {
      //     id: 21,
      //     phase: "p5",
      //     name: "Union Find",
      //     desc: "Connectivity.",
      //     strategy: "Parent array.",
      //     anchor: { logic: "find(x) { return p[x]==x?x:find(p[x]); }" },
      //     problems: [
      //       "Number of Provinces",
      //       "Redundant Connection",
      //       "Accounts Merge",
      //       "Number of Islands II",
      //     ],
      //   },
      //   {
      //     id: 22,
      //     phase: "p5",
      //     name: "Trie",
      //     desc: "Prefix tree.",
      //     strategy: "Node children map.",
      //     anchor: { logic: "node = node.children[char];" },
      //     problems: [
      //       "Implement Trie (Prefix Tree)",
      //       "Design Add and Search Words Data Structure",
      //       "Word Search II",
      //       "Replace Words",
      //     ],
      //   },
      //   {
      //     id: 23,
      //     phase: "p5",
      //     name: "Monotonic Stack",
      //     desc: "Next greater.",
      //     strategy: "Sorted stack.",
      //     anchor: { logic: "while(s && n > s.peek()) pop(); push(n);" },
      //     problems: [
      //       "Next Greater Element I",
      //       "Daily Temperatures",
      //       "Largest Rectangle in Histogram",
      //       "Trapping Rain Water",
      //     ],
      //   },
      //   {
      //     id: 24,
      //     phase: "p5",
      //     name: "Matrix Traversal",
      //     desc: "Islands/Grid.",
      //     strategy: "DFS/BFS neighbors.",
      //     anchor: { logic: "dfs(r,c); mark visited;" },
      //     problems: [
      //       "Number of Islands",
      //       "Max Area of Island",
      //       "Flood Fill",
      //       "Rotting Oranges",
      //     ],
      //   },
      //   {
      //     id: 25,
      //     phase: "p5",
      //     name: "Backtracking",
      //     desc: "Brute force.",
      //     strategy: "Try, recurse, undo.",
      //     anchor: { logic: "place(); backtrack(); remove();" },
      //     problems: [
      //       "N-Queens",
      //       "Sudoku Solver",
      //       "Word Search",
      //       "Generate Parentheses",
      //     ],
      //   },
      // ];
    </script>
  </body>
</html>
